<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `nom` crate."><meta name="keywords" content="rust, rustlang, rust-lang, nom"><title>nom - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><p class='location'>Crate nom</p><div class="sidebar-elems"><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'nom', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><input class="search-input" name="search" autocomplete="off" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/nom/lib.rs.html#1-469' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>nom</a></span></h1><div class='docblock'><h1 id="nom-eating-data-byte-by-byte" class="section-header"><a href="#nom-eating-data-byte-by-byte">nom, eating data byte by byte</a></h1>
<p>nom is a parser combinator library with a focus on safe parsing,
streaming patterns, and as much as possible zero copy.</p>
<h2 id="example" class="section-header"><a href="#example">Example</a></h2>
<pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">nom</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>,<span class="ident">PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">Color</span> {
  <span class="kw">pub</span> <span class="ident">red</span>:     <span class="ident">u8</span>,
  <span class="kw">pub</span> <span class="ident">green</span>:   <span class="ident">u8</span>,
  <span class="kw">pub</span> <span class="ident">blue</span>:    <span class="ident">u8</span>,
}

<span class="kw">fn</span> <span class="ident">from_hex</span>(<span class="ident">input</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">u8</span>, <span class="ident">std</span>::<span class="ident">num</span>::<span class="ident">ParseIntError</span><span class="op">&gt;</span> {
  <span class="ident">u8</span>::<span class="ident">from_str_radix</span>(<span class="ident">input</span>, <span class="number">16</span>)
}

<span class="kw">fn</span> <span class="ident">is_hex_digit</span>(<span class="ident">c</span>: <span class="ident">char</span>) <span class="op">-&gt;</span> <span class="ident">bool</span> {
  <span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">c</span> <span class="kw">as</span> <span class="ident">u8</span>;
  (<span class="ident">c</span> <span class="op">&gt;=</span> <span class="number">0x30</span> <span class="op">&amp;&amp;</span> <span class="ident">c</span> <span class="op">&lt;=</span> <span class="number">0x39</span>) <span class="op">||</span> (<span class="ident">c</span> <span class="op">&gt;=</span> <span class="number">0x41</span> <span class="op">&amp;&amp;</span> <span class="ident">c</span> <span class="op">&lt;=</span> <span class="number">0x46</span>) <span class="op">||</span> (<span class="ident">c</span> <span class="op">&gt;=</span> <span class="number">0x61</span> <span class="op">&amp;&amp;</span> <span class="ident">c</span> <span class="op">&lt;=</span> <span class="number">0x66</span>)
}

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">hex_primary</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span>, <span class="ident">u8</span><span class="op">&gt;</span>,
  <span class="macro">map_res</span><span class="macro">!</span>(<span class="macro">take_while_m_n</span><span class="macro">!</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="ident">is_hex_digit</span>), <span class="ident">from_hex</span>)
);

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">hex_color</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span>, <span class="ident">Color</span><span class="op">&gt;</span>,
  <span class="macro">do_parse</span><span class="macro">!</span>(
           <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;#&quot;</span>)   <span class="op">&gt;&gt;</span>
    <span class="ident">red</span>:   <span class="ident">hex_primary</span> <span class="op">&gt;&gt;</span>
    <span class="ident">green</span>: <span class="ident">hex_primary</span> <span class="op">&gt;&gt;</span>
    <span class="ident">blue</span>:  <span class="ident">hex_primary</span> <span class="op">&gt;&gt;</span>
    (<span class="ident">Color</span> { <span class="ident">red</span>, <span class="ident">green</span>, <span class="ident">blue</span> })
  )
);

<span class="kw">fn</span> <span class="ident">main</span>() {
  <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">hex_color</span>(<span class="string">&quot;#2F14DF&quot;</span>), <span class="prelude-val">Ok</span>((<span class="string">&quot;&quot;</span>, <span class="ident">Color</span> {
    <span class="ident">red</span>: <span class="number">47</span>,
    <span class="ident">green</span>: <span class="number">20</span>,
    <span class="ident">blue</span>: <span class="number">223</span>,
  })));
}</pre>
<p>The code is available on <a href="https://github.com/Geal/nom">Github</a></p>
<p>There are a few <a href="https://github.com/Geal/nom/tree/master/doc">guides</a> with more details
about <a href="https://github.com/Geal/nom/blob/master/doc/how_nom_macros_work.md">the design of nom</a>,
<a href="https://github.com/Geal/nom/blob/master/doc/making_a_new_parser_from_scratch.md">how to write parsers</a>,
or the <a href="https://github.com/Geal/nom/blob/master/doc/error_management.md">error management system</a>.</p>
<p><strong>Looking for a specific combinator? Read the
<a href="https://github.com/Geal/nom/blob/master/doc/choosing_a_combinator.md">&quot;choose a combinator&quot; guide</a></strong></p>
<p>If you are upgrading to nom 2.0, please read the
<a href="https://github.com/Geal/nom/blob/master/doc/upgrading_to_nom_2.md">migration document</a>.</p>
<p>If you are upgrading to nom 4.0, please read the
<a href="https://github.com/Geal/nom/blob/master/doc/upgrading_to_nom_4.md">migration document</a>.</p>
<p>See also the <a href="https://github.com/Geal/nom/blob/master/doc/FAQ.md">FAQ</a>.</p>
<h2 id="parser-combinators" class="section-header"><a href="#parser-combinators">Parser combinators</a></h2>
<p>Parser combinators are an approach to parsers that is very different from
software like <a href="https://en.wikipedia.org/wiki/Lex_(software)">lex</a> and
<a href="https://en.wikipedia.org/wiki/Yacc">yacc</a>. Instead of writing the grammar
in a separate file and generating the corresponding code, you use very small
functions with very specific purpose, like &quot;take 5 bytes&quot;, or &quot;recognize the
word 'HTTP'&quot;, and assemble then in meaningful patterns like &quot;recognize
'HTTP', then a space, then a version&quot;.
The resulting code is small, and looks like the grammar you would have
written with other parser approaches.</p>
<p>This has a few advantages:</p>
<ul>
<li>the parsers are small and easy to write</li>
<li>the parsers components are easy to reuse (if they're general enough, please add them to nom!)</li>
<li>the parsers components are easy to test separately (unit tests and property-based tests)</li>
<li>the parser combination code looks close to the grammar you would have written</li>
<li>you can build partial parsers, specific to the data you need at the moment, and ignore the rest</li>
</ul>
<p>Here is an example of one such parser, to recognize text between parentheses:</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">nom</span>;

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">parens</span>, <span class="macro">delimited</span><span class="macro">!</span>(<span class="macro">char</span><span class="macro">!</span>(<span class="string">&#39;(&#39;</span>), <span class="macro">is_not</span><span class="macro">!</span>(<span class="string">&quot;)&quot;</span>), <span class="macro">char</span><span class="macro">!</span>(<span class="string">&#39;)&#39;</span>)));</pre>
<p>It defines a function named <code>parens</code>, which will recognize a sequence of the character <code>(</code>, the longest byte array not containing <code>)</code>, then the character <code>)</code>, and will return the byte array in the middle.</p>
<p>Here is another parser, written without using nom's macros this time:</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">nom</span>;

<span class="kw">use</span> <span class="ident">nom</span>::{<span class="ident">IResult</span>,<span class="prelude-val">Err</span>,<span class="ident">Needed</span>};

<span class="kw">fn</span> <span class="ident">take4</span>(<span class="ident">i</span>:<span class="kw-2">&amp;</span>[<span class="ident">u8</span>]) <span class="op">-&gt;</span> <span class="ident">IResult</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span>{
  <span class="kw">if</span> <span class="ident">i</span>.<span class="ident">len</span>() <span class="op">&lt;</span> <span class="number">4</span> {
    <span class="prelude-val">Err</span>(<span class="prelude-val">Err</span>::<span class="ident">Incomplete</span>(<span class="ident">Needed</span>::<span class="ident">Size</span>(<span class="number">4</span>)))
  } <span class="kw">else</span> {
    <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="ident">i</span>[<span class="number">4</span>..],<span class="kw-2">&amp;</span><span class="ident">i</span>[<span class="number">0</span>..<span class="number">4</span>]))
  }
}</pre>
<p>This function takes a byte array as input, and tries to consume 4 bytes.
Writing all the parsers manually, like this, is dangerous, despite Rust's safety features. There
are still a lot of mistakes one can make. That's why nom provides a list of macros to help in
developing parsers.</p>
<p>With macros, you would write it like this:</p>

<pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">nom</span>;

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">take4</span>, <span class="macro">take</span><span class="macro">!</span>(<span class="number">4</span>));</pre>
<p>A parser in nom is a function which, for an input type <code>I</code>, an output type <code>O</code>
and an optional error type <code>E</code>, will have the following signature:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><pre class="rust rust-example-rendered ignore">
<span class="kw">fn</span> <span class="ident">parser</span>(<span class="ident">input</span>: <span class="ident">I</span>) <span class="op">-&gt;</span> <span class="ident">IResult</span><span class="op">&lt;</span><span class="ident">I</span>, <span class="ident">O</span>, <span class="ident">E</span><span class="op">&gt;</span>;</pre>
<p>Or like this, if you don't want to specify a custom error type (it will be <code>u32</code> by default):</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><pre class="rust rust-example-rendered ignore">
<span class="kw">fn</span> <span class="ident">parser</span>(<span class="ident">input</span>: <span class="ident">I</span>) <span class="op">-&gt;</span> <span class="ident">IResult</span><span class="op">&lt;</span><span class="ident">I</span>, <span class="ident">O</span><span class="op">&gt;</span>;</pre>
<p><code>IResult</code> is an alias for the <code>Result</code> type:</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">nom</span>::{<span class="ident">Needed</span>, <span class="ident">Context</span>};

<span class="kw">type</span> <span class="ident">IResult</span><span class="op">&lt;</span><span class="ident">I</span>, <span class="ident">O</span>, <span class="ident">E</span> <span class="op">=</span> <span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(<span class="ident">I</span>, <span class="ident">O</span>), <span class="prelude-val">Err</span><span class="op">&lt;</span><span class="ident">I</span>, <span class="ident">E</span><span class="op">&gt;&gt;</span>;

<span class="kw">enum</span> <span class="prelude-val">Err</span><span class="op">&lt;</span><span class="ident">I</span>, <span class="ident">E</span> <span class="op">=</span> <span class="ident">u32</span><span class="op">&gt;</span> {
  <span class="ident">Incomplete</span>(<span class="ident">Needed</span>),
  <span class="ident">Error</span>(<span class="ident">Context</span><span class="op">&lt;</span><span class="ident">I</span>, <span class="ident">E</span><span class="op">&gt;</span>),
  <span class="ident">Failure</span>(<span class="ident">Context</span><span class="op">&lt;</span><span class="ident">I</span>, <span class="ident">E</span><span class="op">&gt;</span>),
}</pre>
<p>It can have the following values:</p>
<ul>
<li>a correct result <code>Ok((I,O))</code> with the first element being the remaining of the input (not parsed yet), and the second the output value;</li>
<li>an error <code>Err(Err::Error(c))</code> with <code>c</code> an enum that contians an error code with its position in the input, and optionally a chain of accumulated errors;</li>
<li>an error <code>Err(Err::Incomplete(Needed))</code> indicating that more input is necessary. <code>Needed</code> can indicate how much data is needed</li>
<li>an error <code>Err(Err::Failure(c))</code>. It works like the <code>Error</code> case, except it indicates an unrecoverable error: we cannot backtrack and test another parser</li>
</ul>
<p>Please refer to the [documentation][doc] for an exhaustive list of parsers. See also the
<a href="https://github.com/Geal/nom/blob/master/doc/choosing_a_combinator.md">&quot;choose a combinator&quot; guide</a>**.</p>
<h2 id="making-new-parsers-with-macros" class="section-header"><a href="#making-new-parsers-with-macros">Making new parsers with macros</a></h2>
<p>Macros are the main way to make new parsers by combining other ones. Those macros accept other macros or function names as arguments. You then need to make a function out of that combinator with <strong><code>named!</code></strong>, or a closure with <strong><code>closure!</code></strong>. Here is how you would do, with the <strong><code>tag!</code></strong> and <strong><code>take!</code></strong> combinators:</p>

<pre class="rust rust-example-rendered">
<span class="macro">named</span><span class="macro">!</span>(<span class="ident">abcd_parser</span>, <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;abcd&quot;</span>)); <span class="comment">// will consume bytes if the input begins with &quot;abcd&quot;</span>

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">take_10</span>, <span class="macro">take</span><span class="macro">!</span>(<span class="number">10</span>));        <span class="comment">// will consume and return 10 bytes of input</span></pre>
<p>The <strong><code>named!</code></strong> macro can take three different syntaxes:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><pre class="rust rust-example-rendered ignore">
<span class="macro">named</span><span class="macro">!</span>(<span class="ident">my_function</span>( <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] ) <span class="op">-&gt;</span> <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;abcd&quot;</span>));

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">my_function</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span>, <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;abcd&quot;</span>));

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">my_function</span>, <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;abcd&quot;</span>)); <span class="comment">// when you know the parser takes &amp;[u8] as input, and returns &amp;[u8] as output</span></pre>
<p><strong>IMPORTANT NOTE</strong>: Rust's macros can be very sensitive to the syntax, so you may encounter an error compiling parsers like this one:</p>

<pre class="rust rust-example-rendered">
<span class="macro">named</span><span class="macro">!</span>(<span class="ident">my_function</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;&gt;</span>, <span class="macro">many0</span><span class="macro">!</span>(<span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;abcd&quot;</span>)));
</pre>
<p>You will get the following error: <code>error: expected an item keyword</code>. This
happens because <code>&gt;&gt;</code> is seen as an operator, so the macro parser does not
recognize what we want. There is a way to avoid it, by inserting a space:</p>

<pre class="rust rust-example-rendered">
<span class="macro">named</span><span class="macro">!</span>(<span class="ident">my_function</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">&gt;</span>, <span class="macro">many0</span><span class="macro">!</span>(<span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;abcd&quot;</span>)));</pre>
<p>This will compile correctly. I am very sorry for this inconvenience.</p>
<h2 id="combining-parsers" class="section-header"><a href="#combining-parsers">Combining parsers</a></h2>
<p>There are more high level patterns, like the <strong><code>alt!</code></strong> combinator, which provides a choice between multiple parsers. If one branch fails, it tries the next, and returns the result of the first parser that succeeds:</p>

<pre class="rust rust-example-rendered">
<span class="macro">named</span><span class="macro">!</span>(<span class="ident">alt_tags</span>, <span class="macro">alt</span><span class="macro">!</span>(<span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;abcd&quot;</span>) <span class="op">|</span> <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;efgh&quot;</span>)));

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">alt_tags</span>(<span class="string">b&quot;abcdxxx&quot;</span>), <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;xxx&quot;</span>[..], <span class="kw-2">&amp;</span><span class="string">b&quot;abcd&quot;</span>[..])));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">alt_tags</span>(<span class="string">b&quot;efghxxx&quot;</span>), <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;xxx&quot;</span>[..], <span class="kw-2">&amp;</span><span class="string">b&quot;efgh&quot;</span>[..])));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">alt_tags</span>(<span class="string">b&quot;ijklxxx&quot;</span>), <span class="prelude-val">Err</span>(<span class="ident">nom</span>::<span class="prelude-val">Err</span>::<span class="ident">Error</span>(<span class="macro">error_position</span><span class="macro">!</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;ijklxxx&quot;</span>[..], <span class="ident">nom</span>::<span class="ident">ErrorKind</span>::<span class="ident">Alt</span>))));</pre>
<p>The pipe <code>|</code> character is used as separator.</p>
<p>The <strong><code>opt!</code></strong> combinator makes a parser optional. If the child parser returns an error, <strong><code>opt!</code></strong> will succeed and return None:</p>

<pre class="rust rust-example-rendered">
<span class="macro">named</span><span class="macro">!</span>( <span class="ident">abcd_opt</span><span class="op">&lt;</span> <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">&gt;</span>, <span class="macro">opt</span><span class="macro">!</span>( <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;abcd&quot;</span>) ) );

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">abcd_opt</span>(<span class="string">b&quot;abcdxxx&quot;</span>), <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;xxx&quot;</span>[..], <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;abcd&quot;</span>[..]))));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">abcd_opt</span>(<span class="string">b&quot;efghxxx&quot;</span>), <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;efghxxx&quot;</span>[..], <span class="prelude-val">None</span>)));</pre>
<p><strong><code>many0!</code></strong> applies a parser 0 or more times, and returns a vector of the aggregated results:</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">str</span>;

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">multi</span><span class="op">&lt;</span> <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">&gt;</span>, <span class="macro">many0</span><span class="macro">!</span>( <span class="macro">map_res</span><span class="macro">!</span>(<span class="macro">tag</span><span class="macro">!</span>( <span class="string">&quot;abcd&quot;</span> ), <span class="ident">str</span>::<span class="ident">from_utf8</span>) ) );
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="string">b&quot;abcdef&quot;</span>;
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="string">b&quot;abcdabcdef&quot;</span>;
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="string">b&quot;azerty&quot;</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">multi</span>(<span class="ident">a</span>), <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;ef&quot;</span>[..],     <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;abcd&quot;</span>])));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">multi</span>(<span class="ident">b</span>), <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;ef&quot;</span>[..],     <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;abcd&quot;</span>])));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">multi</span>(<span class="ident">c</span>), <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;azerty&quot;</span>[..], <span class="ident">Vec</span>::<span class="ident">new</span>())));</pre>
<p>Here are some basic combining macros available:</p>
<ul>
<li><strong><code>opt!</code></strong>: will make the parser optional (if it returns the <code>O</code> type, the new parser returns <code>Option&lt;O&gt;</code>)</li>
<li><strong><code>many0!</code></strong>: will apply the parser 0 or more times (if it returns the <code>O</code> type, the new parser returns <code>Vec&lt;O&gt;</code>)</li>
<li><strong><code>many1!</code></strong>: will apply the parser 1 or more times</li>
</ul>
<p>There are more complex (and more useful) parsers like <code>do_parse!</code> and <code>tuple!</code>, which are used to apply a series of parsers then assemble their results.</p>
<p>Example with <code>tuple!</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">nom</span>::{<span class="ident">ErrorKind</span>, <span class="ident">Needed</span>,<span class="ident">be_u16</span>};

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">tpl</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>], (<span class="ident">u16</span>, <span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="kw-2">&amp;</span>[<span class="ident">u8</span>]) <span class="op">&gt;</span>,
  <span class="macro">tuple</span><span class="macro">!</span>(
    <span class="ident">be_u16</span> ,
    <span class="macro">take</span><span class="macro">!</span>(<span class="number">3</span>),
    <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;fg&quot;</span>)
  )
);

<span class="macro">assert_eq</span><span class="macro">!</span>(
  <span class="ident">tpl</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;abcdefgh&quot;</span>[..]),
  <span class="prelude-val">Ok</span>((
    <span class="kw-2">&amp;</span><span class="string">b&quot;h&quot;</span>[..],
    (<span class="number">0x6162u16</span>, <span class="kw-2">&amp;</span><span class="string">b&quot;cde&quot;</span>[..], <span class="kw-2">&amp;</span><span class="string">b&quot;fg&quot;</span>[..])
  ))
);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">tpl</span>(<span class="kw-2">&amp;</span><span class="string">b&quot;abcde&quot;</span>[..]), <span class="prelude-val">Err</span>(<span class="ident">nom</span>::<span class="prelude-val">Err</span>::<span class="ident">Incomplete</span>(<span class="ident">Needed</span>::<span class="ident">Size</span>(<span class="number">2</span>))));
<span class="kw">let</span> <span class="ident">input</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="string">b&quot;abcdejk&quot;</span>[..];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">tpl</span>(<span class="ident">input</span>), <span class="prelude-val">Err</span>(<span class="ident">nom</span>::<span class="prelude-val">Err</span>::<span class="ident">Error</span>(<span class="macro">error_position</span><span class="macro">!</span>(<span class="kw-2">&amp;</span><span class="ident">input</span>[<span class="number">5</span>..], <span class="ident">ErrorKind</span>::<span class="ident">Tag</span>))));</pre>
<p>Example with <code>do_parse!</code>:</p>

<pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">nom</span>::<span class="ident">IResult</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">PartialEq</span>)]</span>
<span class="kw">struct</span> <span class="ident">A</span> {
  <span class="ident">a</span>: <span class="ident">u8</span>,
  <span class="ident">b</span>: <span class="ident">u8</span>
}

<span class="kw">fn</span> <span class="ident">ret_int1</span>(<span class="ident">i</span>:<span class="kw-2">&amp;</span>[<span class="ident">u8</span>]) <span class="op">-&gt;</span> <span class="ident">IResult</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">u8</span><span class="op">&gt;</span> { <span class="prelude-val">Ok</span>((<span class="ident">i</span>,<span class="number">1</span>)) }
<span class="kw">fn</span> <span class="ident">ret_int2</span>(<span class="ident">i</span>:<span class="kw-2">&amp;</span>[<span class="ident">u8</span>]) <span class="op">-&gt;</span> <span class="ident">IResult</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>], <span class="ident">u8</span><span class="op">&gt;</span> { <span class="prelude-val">Ok</span>((<span class="ident">i</span>,<span class="number">2</span>)) }

<span class="macro">named</span><span class="macro">!</span>(<span class="ident">f</span><span class="op">&lt;</span><span class="kw-2">&amp;</span>[<span class="ident">u8</span>],<span class="ident">A</span><span class="op">&gt;</span>,
  <span class="macro">do_parse</span><span class="macro">!</span>(    <span class="comment">// the parser takes a byte array as input, and returns an A struct</span>
    <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;abcd&quot;</span>)       <span class="op">&gt;&gt;</span>      <span class="comment">// begins with &quot;abcd&quot;</span>
    <span class="macro">opt</span><span class="macro">!</span>(<span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;abcd&quot;</span>)) <span class="op">&gt;&gt;</span>      <span class="comment">// this is an optional parser</span>
    <span class="ident">aa</span>: <span class="ident">ret_int1</span>       <span class="op">&gt;&gt;</span>      <span class="comment">// the return value of ret_int1, if it does not fail, will be stored in aa</span>
    <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;efgh&quot;</span>)       <span class="op">&gt;&gt;</span>
    <span class="ident">bb</span>: <span class="ident">ret_int2</span>       <span class="op">&gt;&gt;</span>
    <span class="macro">tag</span><span class="macro">!</span>(<span class="string">&quot;efgh&quot;</span>)       <span class="op">&gt;&gt;</span>

    (<span class="ident">A</span>{<span class="ident">a</span>: <span class="ident">aa</span>, <span class="ident">b</span>: <span class="ident">bb</span>})          <span class="comment">// the final tuple will be able to use the variable defined previously</span>
  )
);

<span class="kw">let</span> <span class="ident">r</span> <span class="op">=</span> <span class="ident">f</span>(<span class="string">b&quot;abcdabcdefghefghX&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">r</span>, <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;X&quot;</span>[..], <span class="ident">A</span>{<span class="ident">a</span>: <span class="number">1</span>, <span class="ident">b</span>: <span class="number">2</span>})));

<span class="kw">let</span> <span class="ident">r2</span> <span class="op">=</span> <span class="ident">f</span>(<span class="string">b&quot;abcdefghefghX&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">r2</span>, <span class="prelude-val">Ok</span>((<span class="kw-2">&amp;</span><span class="string">b&quot;X&quot;</span>[..], <span class="ident">A</span>{<span class="ident">a</span>: <span class="number">1</span>, <span class="ident">b</span>: <span class="number">2</span>})));</pre>
<p>The double right arrow <code>&gt;&gt;</code> is used as separator between every parser in the sequence, and the last closure can see the variables storing the result of parsers. Unless the specified return type is already a tuple, the final line should be that type wrapped in a tuple.</p>
<p>More examples of <a href="macro.do_parse.html"><code>do_parse!</code></a> and <a href="macro.tuple.html"><code>tuple!</code></a> usage can be found in the <a href="tests/ini.rs">INI file parser example</a>.</p>
<p><strong>Going further:</strong> read the <a href="https://github.com/Geal/nom/tree/master/doc">guides</a>!</p>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub use self::<a class="mod" href="../nom/simple_errors/index.html" title="mod nom::simple_errors">simple_errors</a>::*;</code></td></tr><tr><td><code>pub use self::<a class="mod" href="../nom/methods/index.html" title="mod nom::methods">methods</a>::*;</code></td></tr><tr><td><code>pub use self::<a class="mod" href="../nom/bits/index.html" title="mod nom::bits">bits</a>::*;</code></td></tr><tr><td><code>pub use self::<a class="mod" href="../nom/whitespace/index.html" title="mod nom::whitespace">whitespace</a>::*;</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="mod" href="bits/index.html"
                                  title='mod nom::bits'>bits</a></td>
                           <td class='docblock-short'>
                                <p>Bit level parsers and combinators</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="lib/index.html"
                                  title='mod nom::lib'>lib</a></td>
                           <td class='docblock-short'>
                                <p>Lib module to re-export everything needed from <code>std</code> or <code>core</code>/<code>alloc</code>. This is how <code>serde</code> does
it, albeit there it is not public.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="methods/index.html"
                                  title='mod nom::methods'>methods</a></td>
                           <td class='docblock-short'>
                                <p>Method macro combinators</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="simple_errors/index.html"
                                  title='mod nom::simple_errors'>simple_errors</a></td>
                           <td class='docblock-short'>
                                <p>Error management</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="types/index.html"
                                  title='mod nom::types'>types</a></td>
                           <td class='docblock-short'>
                                <p>Custom input types</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="mod" href="whitespace/index.html"
                                  title='mod nom::whitespace'>whitespace</a></td>
                           <td class='docblock-short'>
                                <p>Support for whitespace delimited formats</p>

                           </td>
                       </tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.add_return_error.html"
                                  title='macro nom::add_return_error'>add_return_error</a></td>
                           <td class='docblock-short'>
                                <p>Add an error if the child parser fails</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.alt.html"
                                  title='macro nom::alt'>alt</a></td>
                           <td class='docblock-short'>
                                <p>Try a list of parsers and return the result of the first successful one</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.alt_complete.html"
                                  title='macro nom::alt_complete'>alt_complete</a></td>
                           <td class='docblock-short'>
                                <p>Is equivalent to the <code>alt!</code> combinator, except that it will not return <code>Incomplete</code>
when one of the constituting parsers returns <code>Incomplete</code>. Instead, it will try the
next alternative in the chain.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.apply.html"
                                  title='macro nom::apply'>apply</a></td>
                           <td class='docblock-short'>
                                <p>emulate function currying: <code>apply!(my_function, arg1, arg2, ...)</code> becomes <code>my_function(input, arg1, arg2, ...)</code></p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.apply_m.html"
                                  title='macro nom::apply_m'>apply_m</a></td>
                           <td class='docblock-short'>
                                <p>emulate function currying for method calls on structs
<code>apply_m!(self.my_function, arg1, arg2, ...)</code> becomes <code>self.my_function(input, arg1, arg2, ...)</code></p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.bits.html"
                                  title='macro nom::bits'>bits</a></td>
                           <td class='docblock-short'>
                                <p>Transforms its byte slice input into a bit stream for the underlying parser. This allows the
given bit stream parser to work on a byte slice input.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.bytes.html"
                                  title='macro nom::bytes'>bytes</a></td>
                           <td class='docblock-short'>
                                <p>Counterpart to bits, bytes! transforms its bit stream input into a byte slice for the underlying
parser, allowing byte-slice parsers to work on bit streams.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.call.html"
                                  title='macro nom::call'>call</a></td>
                           <td class='docblock-short'>
                                <p>Used to wrap common expressions and function as macros</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.call_m.html"
                                  title='macro nom::call_m'>call_m</a></td>
                           <td class='docblock-short'>
                                <p>Used to called methods then move self back into self</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.char.html"
                                  title='macro nom::char'>char</a></td>
                           <td class='docblock-short'>
                                <p>matches one character: `char!(char) =&gt; &amp;<a href="https://doc.rust-lang.org/nightly/std/primitive.u8.html" title="u8">u8</a> -&gt; IResult&lt;&amp;<a href="https://doc.rust-lang.org/nightly/std/primitive.u8.html" title="u8">u8</a>, char&gt;</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.closure.html"
                                  title='macro nom::closure'>closure</a></td>
                           <td class='docblock-short'>
                                <p>Wraps a parser in a closure</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.complete.html"
                                  title='macro nom::complete'>complete</a></td>
                           <td class='docblock-short'>
                                <p>replaces a <code>Incomplete</code> returned by the child parser
with an <code>Error</code></p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.cond.html"
                                  title='macro nom::cond'>cond</a></td>
                           <td class='docblock-short'>
                                <p><code>cond!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
Conditional combinator</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.cond_reduce.html"
                                  title='macro nom::cond_reduce'>cond_reduce</a></td>
                           <td class='docblock-short'>
                                <p><code>cond_reduce!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
Conditional combinator with error</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.cond_with_error.html"
                                  title='macro nom::cond_with_error'>cond_with_error</a></td>
                           <td class='docblock-short'>
                                <p><code>cond_with_error!(bool, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
Conditional combinator</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.count.html"
                                  title='macro nom::count'>count</a></td>
                           <td class='docblock-short'>
                                <p><code>count!(I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the child parser a specified number of times</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.count_fixed.html"
                                  title='macro nom::count_fixed'>count_fixed</a></td>
                           <td class='docblock-short'>
                                <p><code>count_fixed!(O, I -&gt; IResult&lt;I,O&gt;, nb) =&gt; I -&gt; IResult&lt;I, [O; nb]&gt;</code>
Applies the child parser a fixed number of times and returns a fixed size array
The type must be specified and it must be <code>Copy</code></p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.dbg.html"
                                  title='macro nom::dbg'>dbg</a></td>
                           <td class='docblock-short'>
                                <p>Prints a message if the parser fails</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.dbg_dmp.html"
                                  title='macro nom::dbg_dmp'>dbg_dmp</a></td>
                           <td class='docblock-short'>
                                <p>Prints a message and the input if the parser fails</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.delimited.html"
                                  title='macro nom::delimited'>delimited</a></td>
                           <td class='docblock-short'>
                                <p><code>delimited!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,U&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
delimited(opening, X, closing) returns X</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.do_parse.html"
                                  title='macro nom::do_parse'>do_parse</a></td>
                           <td class='docblock-short'>
                                <p><code>do_parse!(I-&gt;IResult&lt;I,A&gt; &gt;&gt; I-&gt;IResult&lt;I,B&gt; &gt;&gt; ... I-&gt;IResult&lt;I,X&gt; , ( O ) ) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
do_parse applies sub parsers in a sequence.
it can store intermediary results and make them available
for later parsers</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.eat_separator.html"
                                  title='macro nom::eat_separator'>eat_separator</a></td>
                           <td class='docblock-short'>
                                <p>helper macros to build a separator parser</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.eof.html"
                                  title='macro nom::eof'>eof</a></td>
                           <td class='docblock-short'>
                                <p><code>eof!()</code> returns its input if it is at the end of input data</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.error_node_position.html"
                                  title='macro nom::error_node_position'>error_node_position</a></td>
                           <td class='docblock-short'>
                                <p>creates a parse error from a <code>nom::ErrorKind</code>,
the position in the input and the next error in
the parsing tree.
if &quot;verbose-errors&quot; is not activated,
it default to only the error code</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.error_position.html"
                                  title='macro nom::error_position'>error_position</a></td>
                           <td class='docblock-short'>
                                <p>creates a parse error from a <code>nom::ErrorKind</code>
and the position in the input
if &quot;verbose-errors&quot; is not activated,
it default to only the error code</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.escaped.html"
                                  title='macro nom::escaped'>escaped</a></td>
                           <td class='docblock-short'>
                                <p><code>escaped!(T -&gt; IResult&lt;T, T&gt;, U, T -&gt; IResult&lt;T, T&gt;) =&gt; T -&gt; IResult&lt;T, T&gt; where T: InputIter, U: AsChar</code>
matches a byte string with escaped characters.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.escaped_transform.html"
                                  title='macro nom::escaped_transform'>escaped_transform</a></td>
                           <td class='docblock-short'>
                                <p><code>escaped_transform!(&amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;, T, &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], Vec&lt;T&gt;&gt;</code>
matches a byte string with escaped characters.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.exact.html"
                                  title='macro nom::exact'>exact</a></td>
                           <td class='docblock-short'>
                                <p><code>exact!()</code> will fail if the child parser does not consume the whole data</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.expr_opt.html"
                                  title='macro nom::expr_opt'>expr_opt</a></td>
                           <td class='docblock-short'>
                                <p><code>expr_opt!(Option&lt;O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
evaluate an expression that returns a Option<T> and returns a Ok((I,T)) if Some</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.expr_res.html"
                                  title='macro nom::expr_res'>expr_res</a></td>
                           <td class='docblock-short'>
                                <p><code>expr_res!(Result&lt;E,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
evaluate an expression that returns a Result&lt;T,E&gt; and returns a Ok((I,T)) if Ok</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.fix_error.html"
                                  title='macro nom::fix_error'>fix_error</a></td>
                           <td class='docblock-short'>
                                <p>translate parser result from IResult&lt;I,O,u32&gt; to IResult&lt;I,O,E&gt; with a custom type</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.flat_map.html"
                                  title='macro nom::flat_map'>flat_map</a></td>
                           <td class='docblock-short'>
                                <p><code>flat_map!(R -&gt; IResult&lt;R,S&gt;, S -&gt; IResult&lt;S,T&gt;) =&gt; R -&gt; IResult&lt;R, T&gt;</code></p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.fold_many0.html"
                                  title='macro nom::fold_many0'>fold_many0</a></td>
                           <td class='docblock-short'>
                                <p><code>fold_many0!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser 0 or more times and folds the list of return values</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.fold_many1.html"
                                  title='macro nom::fold_many1'>fold_many1</a></td>
                           <td class='docblock-short'>
                                <p><code>fold_many1!(I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser 1 or more times and folds the list of return values</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.fold_many_m_n.html"
                                  title='macro nom::fold_many_m_n'>fold_many_m_n</a></td>
                           <td class='docblock-short'>
                                <p><code>fold_many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;, R, Fn(R, O) -&gt; R) =&gt; I -&gt; IResult&lt;I, R&gt;</code>
Applies the parser between m and n times (n included) and folds the list of return value</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.i16.html"
                                  title='macro nom::i16'>i16</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian i16 integer,
otherwise a little endian i16 integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.i32.html"
                                  title='macro nom::i32'>i32</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian i32 integer,
otherwise a little endian i32 integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.i64.html"
                                  title='macro nom::i64'>i64</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian i64 integer,
otherwise a little endian i64 integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.is_a.html"
                                  title='macro nom::is_a'>is_a</a></td>
                           <td class='docblock-short'>
                                <p><code>is_a!(&amp;[T]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes that appear in the provided array</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.is_a_s.html"
                                  title='macro nom::is_a_s'>is_a_s</a></td>
                           <td class='docblock-short'>
                               [<div class='stab deprecated'>Deprecating in 4.0.0</div>] <p><code>is_a_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters that appear in the provided array</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.is_not.html"
                                  title='macro nom::is_not'>is_not</a></td>
                           <td class='docblock-short'>
                                <p><code>is_not!(&amp;[T:AsBytes]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes that do not appear in the provided array</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.is_not_s.html"
                                  title='macro nom::is_not_s'>is_not_s</a></td>
                           <td class='docblock-short'>
                               [<div class='stab deprecated'>Deprecating in 4.0.0</div>] <p><code>is_not_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters that do not appear in the provided array</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.length_bytes.html"
                                  title='macro nom::length_bytes'>length_bytes</a></td>
                           <td class='docblock-short'>
                                <p><code>length_bytes!(&amp;[T] -&gt; IResult&lt;&amp;[T], nb&gt;) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
Gets a number from the first parser, then extracts that many bytes from the
remaining stream</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.length_count.html"
                                  title='macro nom::length_count'>length_count</a></td>
                           <td class='docblock-short'>
                                <p><code>length_count!(I -&gt; IResult&lt;I, nb&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
gets a number from the first parser, then applies the second parser that many times</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.length_data.html"
                                  title='macro nom::length_data'>length_data</a></td>
                           <td class='docblock-short'>
                                <p><code>length_data!(I -&gt; IResult&lt;I, nb&gt;) =&gt; O</code></p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.length_value.html"
                                  title='macro nom::length_value'>length_value</a></td>
                           <td class='docblock-short'>
                                <p><code>length_value!(I -&gt; IResult&lt;I, nb&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code></p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.many0.html"
                                  title='macro nom::many0'>many0</a></td>
                           <td class='docblock-short'>
                                <p><code>many0!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser 0 or more times and returns the list of results in a Vec.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.many1.html"
                                  title='macro nom::many1'>many1</a></td>
                           <td class='docblock-short'>
                                <p><code>many1!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser 1 or more times and returns the list of results in a Vec</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.many_m_n.html"
                                  title='macro nom::many_m_n'>many_m_n</a></td>
                           <td class='docblock-short'>
                                <p><code>many_m_n!(usize, usize, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
Applies the parser between m and n times (n included) and returns the list of
results in a Vec</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.many_till.html"
                                  title='macro nom::many_till'>many_till</a></td>
                           <td class='docblock-short'>
                                <p><code>many_till!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (Vec&lt;O&gt;, P)&gt;</code>
Applies the first parser until the second applies. Returns a tuple containing the list
of results from the first in a Vec and the result of the second.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.map.html"
                                  title='macro nom::map'>map</a></td>
                           <td class='docblock-short'>
                                <p><code>map!(I -&gt; IResult&lt;I,O&gt;, O -&gt; P) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function on the result of a parser</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.map_opt.html"
                                  title='macro nom::map_opt'>map_opt</a></td>
                           <td class='docblock-short'>
                                <p><code>map_opt!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Option&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function returning an Option on the output of a parser</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.map_res.html"
                                  title='macro nom::map_res'>map_res</a></td>
                           <td class='docblock-short'>
                                <p><code>map_res!(I -&gt; IResult&lt;I,O&gt;, O -&gt; Result&lt;P&gt;) =&gt; I -&gt; IResult&lt;I, P&gt;</code>
maps a function returning a Result on the output of a parser</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.method.html"
                                  title='macro nom::method'>method</a></td>
                           <td class='docblock-short'>
                                <p>Makes a method from a parser combination</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.named.html"
                                  title='macro nom::named'>named</a></td>
                           <td class='docblock-short'>
                                <p>Makes a function from a parser combination</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.named_args.html"
                                  title='macro nom::named_args'>named_args</a></td>
                           <td class='docblock-short'>
                                <p>Makes a function from a parser combination with arguments.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.named_attr.html"
                                  title='macro nom::named_attr'>named_attr</a></td>
                           <td class='docblock-short'>
                                <p>Makes a function from a parser combination, with attributes</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.none_of.html"
                                  title='macro nom::none_of'>none_of</a></td>
                           <td class='docblock-short'>
                                <p>matches anything but the provided characters</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.not.html"
                                  title='macro nom::not'>not</a></td>
                           <td class='docblock-short'>
                                <p><code>not!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns a result only if the embedded parser returns Error or Err(Err::Incomplete)
does not consume the input</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.one_of.html"
                                  title='macro nom::one_of'>one_of</a></td>
                           <td class='docblock-short'>
                                <p>matches one of the provided characters</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.opt.html"
                                  title='macro nom::opt'>opt</a></td>
                           <td class='docblock-short'>
                                <p><code>opt!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Option&lt;O&gt;&gt;</code>
make the underlying parser optional</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.opt_res.html"
                                  title='macro nom::opt_res'>opt_res</a></td>
                           <td class='docblock-short'>
                                <p><code>opt_res!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Result&lt;nom::Err,O&gt;&gt;</code>
make the underlying parser optional</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.pair.html"
                                  title='macro nom::pair'>pair</a></td>
                           <td class='docblock-short'>
                                <p><code>pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;</code>
pair(X,Y), returns (x,y)</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.parse_to.html"
                                  title='macro nom::parse_to'>parse_to</a></td>
                           <td class='docblock-short'>
                                <p><code>parse_to!(O) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
uses the <code>parse</code> method from <code>std::str::FromStr</code> to convert the current
input to the specified type</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.peek.html"
                                  title='macro nom::peek'>peek</a></td>
                           <td class='docblock-short'>
                                <p><code>peek!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns a result without consuming the input</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.permutation.html"
                                  title='macro nom::permutation'>permutation</a></td>
                           <td class='docblock-short'>
                                <p><code>permutation!(I -&gt; IResult&lt;I,A&gt;, I -&gt; IResult&lt;I,B&gt;, ... I -&gt; IResult&lt;I,X&gt; ) =&gt; I -&gt; IResult&lt;I, (A,B,...X)&gt;</code>
applies its sub parsers in a sequence, but independent from their order
this parser will only succeed if all of its sub parsers succeed</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.preceded.html"
                                  title='macro nom::preceded'>preceded</a></td>
                           <td class='docblock-short'>
                                <p><code>preceded!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
preceded(opening, X) returns X</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.recognize.html"
                                  title='macro nom::recognize'>recognize</a></td>
                           <td class='docblock-short'>
                                <p><code>recognize!(I -&gt; IResult&lt;I, O&gt; ) =&gt; I -&gt; IResult&lt;I, I&gt;</code>
if the child parser was successful, return the consumed input as produced value</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.return_error.html"
                                  title='macro nom::return_error'>return_error</a></td>
                           <td class='docblock-short'>
                                <p>Prevents backtracking if the child parser fails</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.sep.html"
                                  title='macro nom::sep'>sep</a></td>
                           <td class='docblock-short'>
                                <p>sep is the parser rewriting macro for whitespace separated formats</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.separated_list.html"
                                  title='macro nom::separated_list'>separated_list</a></td>
                           <td class='docblock-short'>
                                <p><code>separated_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
separated_list(sep, X) returns Vec<X> will return Incomplete if there may be more elements</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.separated_list_complete.html"
                                  title='macro nom::separated_list_complete'>separated_list_complete</a></td>
                           <td class='docblock-short'>
                                <p><code>separated_list_complete!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
This is equivalent to the <code>separated_list!</code> combinator, except that it will return <code>Error</code>
when either the separator or element subparser returns <code>Incomplete</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.separated_nonempty_list.html"
                                  title='macro nom::separated_nonempty_list'>separated_nonempty_list</a></td>
                           <td class='docblock-short'>
                                <p><code>separated_nonempty_list!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
separated_nonempty_list(sep, X) returns Vec<X> will return Incomplete if there may be more elements</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.separated_nonempty_list_complete.html"
                                  title='macro nom::separated_nonempty_list_complete'>separated_nonempty_list_complete</a></td>
                           <td class='docblock-short'>
                                <p><code>separated_nonempty_list_complete!(I -&gt; IResult&lt;I,T&gt;, I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, Vec&lt;O&gt;&gt;</code>
This is equivalent to the <code>separated_nonempty_list!</code> combinator, except that it will return
<code>Error</code> when either the separator or element subparser returns <code>Incomplete</code>.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.separated_pair.html"
                                  title='macro nom::separated_pair'>separated_pair</a></td>
                           <td class='docblock-short'>
                                <p><code>separated_pair!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I, T&gt;, I -&gt; IResult&lt;I,P&gt;) =&gt; I -&gt; IResult&lt;I, (O,P)&gt;</code>
separated_pair(X,sep,Y) returns (x,y)</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.switch.html"
                                  title='macro nom::switch'>switch</a></td>
                           <td class='docblock-short'>
                                <p><code>switch!(I -&gt; IResult&lt;I,P&gt;, P =&gt; I -&gt; IResult&lt;I,O&gt; | ... | P =&gt; I -&gt; IResult&lt;I,O&gt; ) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
choose the next parser depending on the result of the first one, if successful,
and returns the result of the second parser</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tag.html"
                                  title='macro nom::tag'>tag</a></td>
                           <td class='docblock-short'>
                                <p><code>tag!(&amp;[T]: nom::AsBytes) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
declares a byte array as a suite to recognize</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tag_bits.html"
                                  title='macro nom::tag_bits'>tag_bits</a></td>
                           <td class='docblock-short'>
                                <p>Matches the given bit pattern.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tag_no_case.html"
                                  title='macro nom::tag_no_case'>tag_no_case</a></td>
                           <td class='docblock-short'>
                                <p><code>tag_no_case!(&amp;[T]) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
declares a case insensitive ascii string as a suite to recognize</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tag_no_case_s.html"
                                  title='macro nom::tag_no_case_s'>tag_no_case_s</a></td>
                           <td class='docblock-short'>
                               [<div class='stab deprecated'>Deprecating in 4.0.0</div>] <p><code>tag_no_case_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
declares a case-insensitive string as a suite to recognize</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tag_s.html"
                                  title='macro nom::tag_s'>tag_s</a></td>
                           <td class='docblock-short'>
                               [<div class='stab deprecated'>Deprecating in 4.0.0</div>] <p><code>tag_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
declares a string as a suite to recognize</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take.html"
                                  title='macro nom::take'>take</a></td>
                           <td class='docblock-short'>
                                <p><code>take!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
generates a parser consuming the specified number of bytes</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_bits.html"
                                  title='macro nom::take_bits'>take_bits</a></td>
                           <td class='docblock-short'>
                                <p>Consumes the specified number of bits and returns them as the specified type.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_s.html"
                                  title='macro nom::take_s'>take_s</a></td>
                           <td class='docblock-short'>
                               [<div class='stab deprecated'>Deprecating in 4.0.0</div>] <p><code>take_s!(nb) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming the specified number of characters</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_str.html"
                                  title='macro nom::take_str'>take_str</a></td>
                           <td class='docblock-short'>
                                <p><code>take_str!(nb) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;str&gt;</code>
same as take! but returning a &amp;str</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_till.html"
                                  title='macro nom::take_till'>take_till</a></td>
                           <td class='docblock-short'>
                                <p><code>take_till!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes until the provided function succeeds</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_till1.html"
                                  title='macro nom::take_till1'>take_till1</a></td>
                           <td class='docblock-short'>
                                <p><code>take_till1!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest non empty list of bytes until the provided function succeeds</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_till1_s.html"
                                  title='macro nom::take_till1_s'>take_till1_s</a></td>
                           <td class='docblock-short'>
                               [<div class='stab deprecated'>Deprecating in 4.0.0</div>] <p><code>take_till1_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest non empty list of characters until the provided function succeeds</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_till_s.html"
                                  title='macro nom::take_till_s'>take_till_s</a></td>
                           <td class='docblock-short'>
                               [<div class='stab deprecated'>Deprecating in 4.0.0</div>] <p><code>take_till_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters until the provided function succeeds</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until.html"
                                  title='macro nom::take_until'>take_until</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data until it finds the specified tag.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until1.html"
                                  title='macro nom::take_until1'>take_until1</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until1!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data (at least one byte) until it finds the specified tag</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_and_consume.html"
                                  title='macro nom::take_until_and_consume'>take_until_and_consume</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_and_consume!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
generates a parser consuming bytes until the specified byte sequence is found, and consumes it</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_and_consume1.html"
                                  title='macro nom::take_until_and_consume1'>take_until_and_consume1</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_and_consume1!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
generates a parser consuming bytes (at least 1) until the specified byte sequence is found, and consumes it</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_and_consume_s.html"
                                  title='macro nom::take_until_and_consume_s'>take_until_and_consume_s</a></td>
                           <td class='docblock-short'>
                               [<div class='stab deprecated'>Deprecating in 4.0.0</div>] <p><code>take_until_and_consume_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming all chars until the specified string is found and consumes it</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_either.html"
                                  title='macro nom::take_until_either'>take_until_either</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_either!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data until it finds any of the specified characters</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_either1.html"
                                  title='macro nom::take_until_either1'>take_until_either1</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_either1!(tag) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data (at least one byte) until it finds any of the specified characters</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_either_and_consume.html"
                                  title='macro nom::take_until_either_and_consume'>take_until_either_and_consume</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_either_and_consume!(chars) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data until it finds any of the specified characters, and consume it</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_either_and_consume1.html"
                                  title='macro nom::take_until_either_and_consume1'>take_until_either_and_consume1</a></td>
                           <td class='docblock-short'>
                                <p><code>take_until_either_and_consume1!(chars) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
consumes data (at least one byte) until it finds any of the specified characters, and consume it</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_until_s.html"
                                  title='macro nom::take_until_s'>take_until_s</a></td>
                           <td class='docblock-short'>
                               [<div class='stab deprecated'>Deprecating in 4.0.0</div>] <p><code>take_until_s!(&amp;str) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
generates a parser consuming all chars until the specified string is found and leaves it in the remaining input</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_while.html"
                                  title='macro nom::take_while'>take_while</a></td>
                           <td class='docblock-short'>
                                <p><code>take_while!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest list of bytes until the provided function fails.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_while1.html"
                                  title='macro nom::take_while1'>take_while1</a></td>
                           <td class='docblock-short'>
                                <p><code>take_while1!(T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns the longest (non empty) list of bytes until the provided function fails.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_while1_s.html"
                                  title='macro nom::take_while1_s'>take_while1_s</a></td>
                           <td class='docblock-short'>
                               [<div class='stab deprecated'>Deprecating in 4.0.0</div>] <p><code>take_while1_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest (non empty) list of characters until the provided function fails.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_while_m_n.html"
                                  title='macro nom::take_while_m_n'>take_while_m_n</a></td>
                           <td class='docblock-short'>
                                <p><code>take_while_m_n!(m: usize, n: usize, T -&gt; bool) =&gt; &amp;[T] -&gt; IResult&lt;&amp;[T], &amp;[T]&gt;</code>
returns a list of bytes or characters for which the provided function returns true.
the returned list's size will be at least m, and at most n</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.take_while_s.html"
                                  title='macro nom::take_while_s'>take_while_s</a></td>
                           <td class='docblock-short'>
                               [<div class='stab deprecated'>Deprecating in 4.0.0</div>] <p><code>take_while_s!(char -&gt; bool) =&gt; &amp;str -&gt; IResult&lt;&amp;str, &amp;str&gt;</code>
returns the longest list of characters until the provided function fails.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tap.html"
                                  title='macro nom::tap'>tap</a></td>
                           <td class='docblock-short'>
                                <p><code>tap!(name: I -&gt; IResult&lt;I,O&gt; =&gt; { block }) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
allows access to the parser's result without affecting it</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.terminated.html"
                                  title='macro nom::terminated'>terminated</a></td>
                           <td class='docblock-short'>
                                <p><code>terminated!(I -&gt; IResult&lt;I,O&gt;, I -&gt; IResult&lt;I,T&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
terminated(X, closing) returns X</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.try_parse.html"
                                  title='macro nom::try_parse'>try_parse</a></td>
                           <td class='docblock-short'>
                                <p>A bit like <code>std::try!</code>, this macro will return the remaining input and
parsed value if the child parser returned <code>Ok</code>, and will do an early
return for the <code>Err</code> side.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.tuple.html"
                                  title='macro nom::tuple'>tuple</a></td>
                           <td class='docblock-short'>
                                <p><code>tuple!(I-&gt;IResult&lt;I,A&gt;, I-&gt;IResult&lt;I,B&gt;, ... I-&gt;IResult&lt;I,X&gt;) =&gt; I -&gt; IResult&lt;I, (A, B, ..., X)&gt;</code>
chains parsers and assemble the sub results in a tuple.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.u16.html"
                                  title='macro nom::u16'>u16</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian u16 integer,
otherwise a little endian u16 integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.u32.html"
                                  title='macro nom::u32'>u32</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian u32 integer,
otherwise a little endian u32 integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.u64.html"
                                  title='macro nom::u64'>u64</a></td>
                           <td class='docblock-short'>
                                <p>if the parameter is nom::Endianness::Big, parse a big endian u64 integer,
otherwise a little endian u64 integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.value.html"
                                  title='macro nom::value'>value</a></td>
                           <td class='docblock-short'>
                                <p><code>value!(T, R -&gt; IResult&lt;R, S&gt; ) =&gt; R -&gt; IResult&lt;R, T&gt;</code></p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.verify.html"
                                  title='macro nom::verify'>verify</a></td>
                           <td class='docblock-short'>
                                <p><code>verify!(I -&gt; IResult&lt;I,O&gt;, O -&gt; bool) =&gt; I -&gt; IResult&lt;I, O&gt;</code>
returns the result of the child parser if it satisfies a verification function</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.wrap_sep.html"
                                  title='macro nom::wrap_sep'>wrap_sep</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="macro" href="macro.ws.html"
                                  title='macro nom::ws'>ws</a></td>
                           <td class='docblock-short'>
                                <p><code>ws!(I -&gt; IResult&lt;I,O&gt;) =&gt; I -&gt; IResult&lt;I, O&gt;</code></p>

                           </td>
                       </tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.CompareResult.html"
                                  title='enum nom::CompareResult'>CompareResult</a></td>
                           <td class='docblock-short'>
                                <p>indicates wether a comparison was successful, an error, or
if more data was needed</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.Endianness.html"
                                  title='enum nom::Endianness'>Endianness</a></td>
                           <td class='docblock-short'>
                                <p>Configurable endianness</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.Err.html"
                                  title='enum nom::Err'>Err</a></td>
                           <td class='docblock-short'>
                                <p>The <code>Err</code> enum indicates the parser was not successful</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.ErrorKind.html"
                                  title='enum nom::ErrorKind'>ErrorKind</a></td>
                           <td class='docblock-short'>
                                <p>indicates which parser returned an error</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="enum" href="enum.Needed.html"
                                  title='enum nom::Needed'>Needed</a></td>
                           <td class='docblock-short'>
                                <p>Contains information on needed data if a parser returned <code>Incomplete</code></p>

                           </td>
                       </tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.AsBytes.html"
                                  title='trait nom::AsBytes'>AsBytes</a></td>
                           <td class='docblock-short'>
                                <p>casts the input type to a byte slice</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.AsChar.html"
                                  title='trait nom::AsChar'>AsChar</a></td>
                           <td class='docblock-short'>
                                <p>transforms common types to a char for basic token parsing</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.AtEof.html"
                                  title='trait nom::AtEof'>AtEof</a></td>
                           <td class='docblock-short'>
                                <p>indicates whether more data can come later in input</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.Compare.html"
                                  title='trait nom::Compare'>Compare</a></td>
                           <td class='docblock-short'>
                                <p>abstracts comparison operations</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.Convert.html"
                                  title='trait nom::Convert'>Convert</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.ExtendInto.html"
                                  title='trait nom::ExtendInto'>ExtendInto</a></td>
                           <td class='docblock-short'>
                                <p>abtracts something which can extend an <code>Extend</code></p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.FindSubstring.html"
                                  title='trait nom::FindSubstring'>FindSubstring</a></td>
                           <td class='docblock-short'>
                                <p>look for a substring in self</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.FindToken.html"
                                  title='trait nom::FindToken'>FindToken</a></td>
                           <td class='docblock-short'>
                                <p>look for self in the given input stream</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.HexDisplay.html"
                                  title='trait nom::HexDisplay'>HexDisplay</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.InputIter.html"
                                  title='trait nom::InputIter'>InputIter</a></td>
                           <td class='docblock-short'>
                                <p>abstracts common iteration operations on the input type</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.InputLength.html"
                                  title='trait nom::InputLength'>InputLength</a></td>
                           <td class='docblock-short'>
                                <p>abstract method to calculate the input length</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.InputTake.html"
                                  title='trait nom::InputTake'>InputTake</a></td>
                           <td class='docblock-short'>
                                <p>abstracts slicing operations</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.InputTakeAtPosition.html"
                                  title='trait nom::InputTakeAtPosition'>InputTakeAtPosition</a></td>
                           <td class='docblock-short'>
                                <p>methods to take as much input as possible until the provided function returns true for the current element</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.Offset.html"
                                  title='trait nom::Offset'>Offset</a></td>
                           <td class='docblock-short'>
                                <p>useful functions to calculate the offset between slices and show a hexdump of a slice</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.ParseTo.html"
                                  title='trait nom::ParseTo'>ParseTo</a></td>
                           <td class='docblock-short'>
                                <p>used to integrate str's parse() method</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.Slice.html"
                                  title='trait nom::Slice'>Slice</a></td>
                           <td class='docblock-short'>
                                <p>slicing operations using ranges</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="trait" href="trait.UnspecializedInput.html"
                                  title='trait nom::UnspecializedInput'>UnspecializedInput</a></td>
                           <td class='docblock-short'>
                                <p>Dummy trait used for default implementations (currently only used for <code>InputTakeAtPosition</code>).</p>

                           </td>
                       </tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.alpha.html"
                                  title='fn nom::alpha'>alpha</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes one or more lowercase and uppercase alphabetic characters: a-zA-Z</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.alpha0.html"
                                  title='fn nom::alpha0'>alpha0</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes zero or more lowercase and uppercase alphabetic characters: a-zA-Z</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.alpha1.html"
                                  title='fn nom::alpha1'>alpha1</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes one or more lowercase and uppercase alphabetic characters: a-zA-Z</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.alphanumeric.html"
                                  title='fn nom::alphanumeric'>alphanumeric</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes one or more numerical and alphabetic characters: 0-9a-zA-Z</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.alphanumeric0.html"
                                  title='fn nom::alphanumeric0'>alphanumeric0</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes zero or more numerical and alphabetic characters: 0-9a-zA-Z</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.alphanumeric1.html"
                                  title='fn nom::alphanumeric1'>alphanumeric1</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes one or more numerical and alphabetic characters: 0-9a-zA-Z</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.anychar.html"
                                  title='fn nom::anychar'>anychar</a></td>
                           <td class='docblock-short'>
                                <p>matches one byte as a character. Note that the input type will
accept a <code>str</code>, but not a <code>&amp;[u8]</code>, unlike many other nom parsers.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_f32.html"
                                  title='fn nom::be_f32'>be_f32</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes big endian 4 bytes floating point number</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_f64.html"
                                  title='fn nom::be_f64'>be_f64</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes big endian 8 bytes floating point number</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_i8.html"
                                  title='fn nom::be_i8'>be_i8</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes a signed 1 byte integer (equivalent to take!(1)</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_i16.html"
                                  title='fn nom::be_i16'>be_i16</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes big endian signed 2 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_i24.html"
                                  title='fn nom::be_i24'>be_i24</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes big endian signed 3 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_i32.html"
                                  title='fn nom::be_i32'>be_i32</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes big endian signed 4 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_i64.html"
                                  title='fn nom::be_i64'>be_i64</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes big endian signed 8 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_u8.html"
                                  title='fn nom::be_u8'>be_u8</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes an unsigned 1 byte integer (equivalent to take!(1)</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_u16.html"
                                  title='fn nom::be_u16'>be_u16</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes big endian unsigned 2 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_u24.html"
                                  title='fn nom::be_u24'>be_u24</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes big endian unsigned 3 byte integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_u32.html"
                                  title='fn nom::be_u32'>be_u32</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes big endian unsigned 4 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.be_u64.html"
                                  title='fn nom::be_u64'>be_u64</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes big endian unsigned 8 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.begin.html"
                                  title='fn nom::begin'>begin</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.code_from_offset.html"
                                  title='fn nom::code_from_offset'>code_from_offset</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.crlf.html"
                                  title='fn nom::crlf'>crlf</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.digit.html"
                                  title='fn nom::digit'>digit</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes one or more numerical characters: 0-9</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.digit0.html"
                                  title='fn nom::digit0'>digit0</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes zero or more numerical characters: 0-9</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.digit1.html"
                                  title='fn nom::digit1'>digit1</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes one or more numerical characters: 0-9</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.double.html"
                                  title='fn nom::double'>double</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes floating point number in a byte string and returns a f64</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.double_s.html"
                                  title='fn nom::double_s'>double_s</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes floating point number in a string and returns a f64</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.eol.html"
                                  title='fn nom::eol'>eol</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.error_to_u32.html"
                                  title='fn nom::error_to_u32'>error_to_u32</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.float.html"
                                  title='fn nom::float'>float</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes floating point number in a byte string and returns a f32</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.float_s.html"
                                  title='fn nom::float_s'>float_s</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes floating point number in a string and returns a f32</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.hex_digit.html"
                                  title='fn nom::hex_digit'>hex_digit</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes one or more hexadecimal numerical characters: 0-9, A-F, a-f</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.hex_digit0.html"
                                  title='fn nom::hex_digit0'>hex_digit0</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes zero or more hexadecimal numerical characters: 0-9, A-F, a-f</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.hex_digit1.html"
                                  title='fn nom::hex_digit1'>hex_digit1</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes one or more hexadecimal numerical characters: 0-9, A-F, a-f</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.hex_u32.html"
                                  title='fn nom::hex_u32'>hex_u32</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes a hex-encoded integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.is_alphabetic.html"
                                  title='fn nom::is_alphabetic'>is_alphabetic</a></td>
                           <td class='docblock-short'>
                                <p>Tests if byte is ASCII alphabetic: A-Z, a-z</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.is_alphanumeric.html"
                                  title='fn nom::is_alphanumeric'>is_alphanumeric</a></td>
                           <td class='docblock-short'>
                                <p>Tests if byte is ASCII alphanumeric: A-Z, a-z, 0-9</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.is_digit.html"
                                  title='fn nom::is_digit'>is_digit</a></td>
                           <td class='docblock-short'>
                                <p>Tests if byte is ASCII digit: 0-9</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.is_hex_digit.html"
                                  title='fn nom::is_hex_digit'>is_hex_digit</a></td>
                           <td class='docblock-short'>
                                <p>Tests if byte is ASCII hex digit: 0-9, A-F, a-f</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.is_oct_digit.html"
                                  title='fn nom::is_oct_digit'>is_oct_digit</a></td>
                           <td class='docblock-short'>
                                <p>Tests if byte is ASCII octal digit: 0-7</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.is_space.html"
                                  title='fn nom::is_space'>is_space</a></td>
                           <td class='docblock-short'>
                                <p>Tests if byte is ASCII space or tab</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_f32.html"
                                  title='fn nom::le_f32'>le_f32</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes little endian 4 bytes floating point number</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_f64.html"
                                  title='fn nom::le_f64'>le_f64</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes little endian 8 bytes floating point number</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_i8.html"
                                  title='fn nom::le_i8'>le_i8</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes a signed 1 byte integer (equivalent to take!(1)</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_i16.html"
                                  title='fn nom::le_i16'>le_i16</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes little endian signed 2 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_i24.html"
                                  title='fn nom::le_i24'>le_i24</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes little endian signed 3 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_i32.html"
                                  title='fn nom::le_i32'>le_i32</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes little endian signed 4 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_i64.html"
                                  title='fn nom::le_i64'>le_i64</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes little endian signed 8 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_u8.html"
                                  title='fn nom::le_u8'>le_u8</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes an unsigned 1 byte integer (equivalent to take!(1)</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_u16.html"
                                  title='fn nom::le_u16'>le_u16</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes little endian unsigned 2 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_u24.html"
                                  title='fn nom::le_u24'>le_u24</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes little endian unsigned 3 byte integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_u32.html"
                                  title='fn nom::le_u32'>le_u32</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes little endian unsigned 4 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.le_u64.html"
                                  title='fn nom::le_u64'>le_u64</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes little endian unsigned 8 bytes integer</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.line_ending.html"
                                  title='fn nom::line_ending'>line_ending</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes an end of line (both '\n' and '\r\n')</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.multispace.html"
                                  title='fn nom::multispace'>multispace</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes one or more spaces, tabs, carriage returns and line feeds</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.multispace0.html"
                                  title='fn nom::multispace0'>multispace0</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes zero or more spaces, tabs, carriage returns and line feeds</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.multispace1.html"
                                  title='fn nom::multispace1'>multispace1</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes one or more spaces, tabs, carriage returns and line feeds</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.need_more.html"
                                  title='fn nom::need_more'>need_more</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.need_more_err.html"
                                  title='fn nom::need_more_err'>need_more_err</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.newline.html"
                                  title='fn nom::newline'>newline</a></td>
                           <td class='docblock-short'>
                                <p>Matches a newline character '\n'</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.non_empty.html"
                                  title='fn nom::non_empty'>non_empty</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes non empty buffers</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.not_line_ending.html"
                                  title='fn nom::not_line_ending'>not_line_ending</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.oct_digit.html"
                                  title='fn nom::oct_digit'>oct_digit</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes one or more octal characters: 0-7</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.oct_digit0.html"
                                  title='fn nom::oct_digit0'>oct_digit0</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes zero or more octal characters: 0-7</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.oct_digit1.html"
                                  title='fn nom::oct_digit1'>oct_digit1</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes one or more octal characters: 0-7</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.print.html"
                                  title='fn nom::print'>print</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.print_codes.html"
                                  title='fn nom::print_codes'>print_codes</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.recognize_float.html"
                                  title='fn nom::recognize_float'>recognize_float</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.reset_color.html"
                                  title='fn nom::reset_color'>reset_color</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.rest.html"
                                  title='fn nom::rest'>rest</a></td>
                           <td class='docblock-short'>
                                <p>Return the remaining input.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.rest_s.html"
                                  title='fn nom::rest_s'>rest_s</a></td>
                           <td class='docblock-short'>
                                <p>Return the remaining input, for strings.</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.sized_buffer.html"
                                  title='fn nom::sized_buffer'>sized_buffer</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.slice_to_offsets.html"
                                  title='fn nom::slice_to_offsets'>slice_to_offsets</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.space.html"
                                  title='fn nom::space'>space</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes one or more spaces and tabs</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.space0.html"
                                  title='fn nom::space0'>space0</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes zero or more spaces and tabs</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.space1.html"
                                  title='fn nom::space1'>space1</a></td>
                           <td class='docblock-short'>
                                <p>Recognizes one or more spaces and tabs</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.tab.html"
                                  title='fn nom::tab'>tab</a></td>
                           <td class='docblock-short'>
                                <p>Matches a tab character '\t'</p>

                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.tag_cl.html"
                                  title='fn nom::tag_cl'>tag_cl</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr>
                       <tr class=' module-item'>
                           <td><a class="fn" href="fn.write_color.html"
                                  title='fn nom::write_color'>write_color</a></td>
                           <td class='docblock-short'>
                                
                           </td>
                       </tr></table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table>
                       <tr class=' module-item'>
                           <td><a class="type" href="type.IResult.html"
                                  title='type nom::IResult'>IResult</a></td>
                           <td class='docblock-short'>
                                <p>Holds the result of parsing functions</p>

                           </td>
                       </tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g. <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g. <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g. <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "nom";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>